// Generated by SpatialOS codegen. DO NOT EDIT!
// source: automaton/player/movement.schema
#include <automaton/player/movement.h>
#include <improbable/protobuf_interop.h>

namespace automaton {
namespace player {

// Implementation of MovementData.
//----------------------------------------------------------------

MovementData::MovementData(
    bool moving,
    const ::automaton::Quaternion& orientation)
: _moving{moving}
, _orientation{orientation} {}

bool MovementData::operator==(const MovementData& value) const {
  return
      _moving == value._moving &&
      _orientation == value._orientation;
}

bool MovementData::operator!=(const MovementData& value) const {
  return !operator==(value);
}

bool MovementData::moving() const {
  return _moving;
}

bool& MovementData::moving() {
  return _moving;
}

MovementData& MovementData::set_moving(bool value) {
  _moving = value;
  return *this;
}

const ::automaton::Quaternion& MovementData::orientation() const {
  return _orientation;
}

::automaton::Quaternion& MovementData::orientation() {
  return _orientation;
}

MovementData& MovementData::set_orientation(const ::automaton::Quaternion& value) {
  _orientation = value;
  return *this;
}

// Implementation of Movement.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Movement::ComponentId;

bool Movement::Update::operator==(const Movement::Update& value) const {
  return
      _moving == value._moving &&
      _orientation == value._orientation;
}

bool Movement::Update::operator!=(const Movement::Update& value) const {
  return !operator==(value);
}

Movement::Update Movement::Update::FromInitialData(const ::automaton::player::MovementData& data) {
  Movement::Update update;
  update._moving.emplace(data.moving());
  update._orientation.emplace(data.orientation());
  return update;
}

::automaton::player::MovementData Movement::Update::ToInitialData() const {
  return ::automaton::player::MovementData(
      *_moving,
      *_orientation);
}

void Movement::Update::ApplyTo(::automaton::player::MovementData& data) const {
  if (_moving) {
    data.set_moving(*_moving);
  }
  if (_orientation) {
    data.set_orientation(*_orientation);
  }
}

const ::worker::Option< bool >& Movement::Update::moving() const {
  return _moving;
}

::worker::Option< bool >& Movement::Update::moving() {
  return _moving;
}

Movement::Update& Movement::Update::set_moving(bool value) {
  _moving.emplace(value); return *this;
}

const ::worker::Option< ::automaton::Quaternion >& Movement::Update::orientation() const {
  return _orientation;
}

::worker::Option< ::automaton::Quaternion >& Movement::Update::orientation() {
  return _orientation;
}

Movement::Update& Movement::Update::set_orientation(const ::automaton::Quaternion& value) {
  _orientation.emplace(value); return *this;
}

// Serialization helpers.
//----------------------------------------------------------------

namespace detail {

void Write_MovementData(
    const ::automaton::player::MovementData& data, ::Pbio_Object* object) {
  ::Pbio_AddBool(object, 1, static_cast<std::uint8_t>(data.moving()));
  ::automaton::detail::Write_Quaternion(data.orientation(), ::Pbio_AddObject(object, 2));
}

::automaton::player::MovementData Read_MovementData(::Pbio_Object* object) {
  auto _moving = ::Pbio_GetBool(object, 1) != 0;
  auto _orientation = ::automaton::detail::Read_Quaternion(::Pbio_GetObject(object, 2));
  return {
      std::move(_moving),
      std::move(_orientation)};
}

namespace {

void VtableBufferFree_Movement(::worker::ComponentId, std::uint8_t* buffer) {
  delete[] buffer;
}

void VtableFree_Movement(
    ::worker::ComponentId, std::uint8_t object_type,
    ::worker::detail::ClientObject* object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    delete static_cast< ::automaton::player::Movement::Update* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    delete static_cast< ::automaton::player::MovementData* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request ||
             object_type == ::worker::detail::ClientComponentVtable::Response) {
    delete static_cast< GenericCommandObject_Movement* >(object);
  }
}

::worker::detail::ClientObject* VtableCopy_Movement(
    ::worker::ComponentId, std::uint8_t, ::worker::detail::ClientObject* object) {
  return object;
}

std::uint8_t VtableDeserialize_Movement(
    ::worker::ComponentId, std::uint8_t object_type, const std::uint8_t* buffer,
    std::uint32_t length, ::worker::detail::ClientObject** object) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  ::Pbio_MergeFromBuffer(root, buffer, length);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    *object = new ::automaton::player::Movement::Update;
    auto client_object = static_cast< ::automaton::player::Movement::Update* >(*object);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::Pbio_GetObject(
          ::Pbio_GetObject(root, /* entity_state */ 2), 30001);
      if (::Pbio_GetBoolCount(state_object, 1)) {
        auto _moving = ::Pbio_GetBool(state_object, 1) != 0;
        client_object->moving().emplace(std::move(_moving));
      }
      if (::Pbio_GetObjectCount(state_object, 2)) {
        auto _orientation = ::automaton::detail::Read_Quaternion(::Pbio_GetObject(state_object, 2));
        client_object->orientation().emplace(std::move(_orientation));
      }
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    *object = new ::automaton::player::MovementData{::automaton::player::detail::Read_MovementData(::Pbio_GetObject(root, 30001))};
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
  }
  return ::Pbio_HasError(pbio.get()) == 0;
}

void VtableSerialize_Movement(
    ::worker::ComponentId, std::uint8_t object_type,
    const ::worker::detail::ClientObject* object, std::uint8_t** buffer,
    std::uint32_t* length) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  static_cast<void>(object);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    const auto& data = *static_cast< const ::automaton::player::Movement::Update* >(object);
    {
      auto state_object = ::Pbio_AddObject(
          ::Pbio_AddObject(root, /* entity_state */ 2), 30001);
      if (data.moving()) {
        ::Pbio_AddBool(state_object, 1, static_cast<std::uint8_t>((*data.moving())));
      }
      if (data.orientation()) {
        ::automaton::detail::Write_Quaternion((*data.orientation()), ::Pbio_AddObject(state_object, 2));
      }
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::automaton::player::detail::Write_MovementData(
        *static_cast< const ::automaton::player::MovementData* >(object),
        ::Pbio_AddObject(root, 30001));
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    ::Pbio_AddObject(root, 30001);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    ::Pbio_AddObject(root, 30001);
  }
  *length = ::Pbio_GetWriteBufferLength(root);
  *buffer = new std::uint8_t[*length];
  ::Pbio_WriteToBuffer(root, *buffer);
}

}  // anonymous namespace

const ::worker::detail::ClientComponentVtable& Vtable_Movement() {
  static const ::worker::detail::ClientComponentVtable vtable = {
      30001,
      &::automaton::player::detail::VtableBufferFree_Movement,
      &::automaton::player::detail::VtableFree_Movement,
      &::automaton::player::detail::VtableCopy_Movement,
      &::automaton::player::detail::VtableDeserialize_Movement,
      &::automaton::player::detail::VtableSerialize_Movement,
  };
  return vtable;
}

}  // ::detail

}  // ::player
}  // ::automaton
