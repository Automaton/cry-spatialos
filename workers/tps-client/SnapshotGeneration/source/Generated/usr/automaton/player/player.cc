// Generated by SpatialOS codegen. DO NOT EDIT!
// source: automaton/player/player.schema
#include <automaton/player/player.h>
#include <improbable/protobuf_interop.h>

namespace automaton {
namespace player {

// Implementation of Heartbeat.
//----------------------------------------------------------------

Heartbeat::Heartbeat() {}

bool Heartbeat::operator==(const Heartbeat&) const {
  return true;
}

bool Heartbeat::operator!=(const Heartbeat& value) const {
  return !operator==(value);
}

// Implementation of KilledPlayer.
//----------------------------------------------------------------

KilledPlayer::KilledPlayer() {}

bool KilledPlayer::operator==(const KilledPlayer&) const {
  return true;
}

bool KilledPlayer::operator!=(const KilledPlayer& value) const {
  return !operator==(value);
}

// Implementation of PlayerData.
//----------------------------------------------------------------

PlayerData::PlayerData() {}

bool PlayerData::operator==(const PlayerData&) const {
  return true;
}

bool PlayerData::operator!=(const PlayerData& value) const {
  return !operator==(value);
}

// Implementation of Player.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Player::ComponentId;

bool Player::Update::operator==(const Player::Update& value) const {
  return
      _heartbeat == value._heartbeat &&
      _killed_player == value._killed_player;
}

bool Player::Update::operator!=(const Player::Update& value) const {
  return !operator==(value);
}

Player::Update Player::Update::FromInitialData(const ::automaton::player::PlayerData&) {
  return Player::Update{};
}

::automaton::player::PlayerData Player::Update::ToInitialData() const {
  return ::automaton::player::PlayerData();
}

void Player::Update::ApplyTo(::automaton::player::PlayerData&) const {
}

const ::worker::List< ::automaton::player::Heartbeat >& Player::Update::heartbeat() const {
  return _heartbeat;
}

::worker::List< ::automaton::player::Heartbeat >& Player::Update::heartbeat() {
  return _heartbeat;
}

Player::Update& Player::Update::add_heartbeat(const ::automaton::player::Heartbeat& value) {
  _heartbeat.emplace_back(value);
  return *this;
}

const ::worker::List< ::automaton::player::KilledPlayer >& Player::Update::killed_player() const {
  return _killed_player;
}

::worker::List< ::automaton::player::KilledPlayer >& Player::Update::killed_player() {
  return _killed_player;
}

Player::Update& Player::Update::add_killed_player(const ::automaton::player::KilledPlayer& value) {
  _killed_player.emplace_back(value);
  return *this;
}

// Serialization helpers.
//----------------------------------------------------------------

namespace detail {

void Write_Heartbeat(const ::automaton::player::Heartbeat&, ::Pbio_Object*) {}

::automaton::player::Heartbeat Read_Heartbeat(::Pbio_Object*) {
  return {};
}

void Write_KilledPlayer(const ::automaton::player::KilledPlayer&, ::Pbio_Object*) {}

::automaton::player::KilledPlayer Read_KilledPlayer(::Pbio_Object*) {
  return {};
}

void Write_PlayerData(const ::automaton::player::PlayerData&, ::Pbio_Object*) {}

::automaton::player::PlayerData Read_PlayerData(::Pbio_Object*) {
  return {};
}

namespace {

void VtableBufferFree_Player(::worker::ComponentId, std::uint8_t* buffer) {
  delete[] buffer;
}

void VtableFree_Player(
    ::worker::ComponentId, std::uint8_t object_type,
    ::worker::detail::ClientObject* object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    delete static_cast< ::automaton::player::Player::Update* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    delete static_cast< ::automaton::player::PlayerData* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request ||
             object_type == ::worker::detail::ClientComponentVtable::Response) {
    delete static_cast< GenericCommandObject_Player* >(object);
  }
}

::worker::detail::ClientObject* VtableCopy_Player(
    ::worker::ComponentId, std::uint8_t, ::worker::detail::ClientObject* object) {
  return object;
}

std::uint8_t VtableDeserialize_Player(
    ::worker::ComponentId, std::uint8_t object_type, const std::uint8_t* buffer,
    std::uint32_t length, ::worker::detail::ClientObject** object) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  ::Pbio_MergeFromBuffer(root, buffer, length);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    *object = new ::automaton::player::Player::Update;
    auto client_object = static_cast< ::automaton::player::Player::Update* >(*object);
    {
    }
    {
      auto event_object = ::Pbio_GetObject(
          ::Pbio_GetObject(root, /* entity_event */ 3), 30002);
      ::worker::List< ::automaton::player::Heartbeat > _heartbeat;
      auto _heartbeat_count = ::Pbio_GetObjectCount(event_object, 1);
      for (std::uint32_t index = 0; index < _heartbeat_count; ++index) {
        _heartbeat.emplace_back(::automaton::player::detail::Read_Heartbeat(::Pbio_IndexObject(event_object, 1, index)));
      }
      client_object->heartbeat() = std::move(_heartbeat);
      ::worker::List< ::automaton::player::KilledPlayer > _killed_player;
      auto _killed_player_count = ::Pbio_GetObjectCount(event_object, 2);
      for (std::uint32_t index = 0; index < _killed_player_count; ++index) {
        _killed_player.emplace_back(::automaton::player::detail::Read_KilledPlayer(::Pbio_IndexObject(event_object, 2, index)));
      }
      client_object->killed_player() = std::move(_killed_player);
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    *object = new ::automaton::player::PlayerData{::automaton::player::detail::Read_PlayerData(::Pbio_GetObject(root, 30002))};
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
  }
  return ::Pbio_HasError(pbio.get()) == 0;
}

void VtableSerialize_Player(
    ::worker::ComponentId, std::uint8_t object_type,
    const ::worker::detail::ClientObject* object, std::uint8_t** buffer,
    std::uint32_t* length) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  static_cast<void>(object);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    const auto& data = *static_cast< const ::automaton::player::Player::Update* >(object);
    {
      ::Pbio_AddObject(
          ::Pbio_AddObject(root, /* entity_state */ 2), 30002);
    }
    {
      auto event_object = ::Pbio_AddObject(
      ::Pbio_AddObject(root, /* entity_event */ 3), 30002);
      for (const auto& item : data.heartbeat()) {
        ::automaton::player::detail::Write_Heartbeat(item, ::Pbio_AddObject(event_object, 1));
      }
      for (const auto& item : data.killed_player()) {
        ::automaton::player::detail::Write_KilledPlayer(item, ::Pbio_AddObject(event_object, 2));
      }
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::automaton::player::detail::Write_PlayerData(
        *static_cast< const ::automaton::player::PlayerData* >(object),
        ::Pbio_AddObject(root, 30002));
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    ::Pbio_AddObject(root, 30002);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    ::Pbio_AddObject(root, 30002);
  }
  *length = ::Pbio_GetWriteBufferLength(root);
  *buffer = new std::uint8_t[*length];
  ::Pbio_WriteToBuffer(root, *buffer);
}

}  // anonymous namespace

const ::worker::detail::ClientComponentVtable& Vtable_Player() {
  static const ::worker::detail::ClientComponentVtable vtable = {
      30002,
      &::automaton::player::detail::VtableBufferFree_Player,
      &::automaton::player::detail::VtableFree_Player,
      &::automaton::player::detail::VtableCopy_Player,
      &::automaton::player::detail::VtableDeserialize_Player,
      &::automaton::player::detail::VtableSerialize_Player,
  };
  return vtable;
}

}  // ::detail

}  // ::player
}  // ::automaton
