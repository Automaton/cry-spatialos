// Generated by SpatialOS codegen. DO NOT EDIT!
// source: automaton/player/bullet.schema
#include <automaton/player/bullet.h>
#include <improbable/protobuf_interop.h>

namespace automaton {
namespace player {

// Implementation of BulletData.
//----------------------------------------------------------------

BulletData::BulletData(
    ::worker::EntityId creator,
    const ::automaton::Quaternion& rotation)
: _creator{creator}
, _rotation{rotation} {}

BulletData BulletData::Create() {
  return {
      0,
      ::automaton::Quaternion::Create()};
}

bool BulletData::operator==(const BulletData& value) const {
  return
      _creator == value._creator &&
      _rotation == value._rotation;
}

bool BulletData::operator!=(const BulletData& value) const {
  return !operator==(value);
}

::worker::EntityId BulletData::creator() const {
  return _creator;
}

::worker::EntityId& BulletData::creator() {
  return _creator;
}

BulletData& BulletData::set_creator(::worker::EntityId value) {
  _creator = value;
  return *this;
}

const ::automaton::Quaternion& BulletData::rotation() const {
  return _rotation;
}

::automaton::Quaternion& BulletData::rotation() {
  return _rotation;
}

BulletData& BulletData::set_rotation(const ::automaton::Quaternion& value) {
  _rotation = value;
  return *this;
}

// Implementation of Bullet.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Bullet::ComponentId;

bool Bullet::Update::operator==(const Bullet::Update& value) const {
  return
      _creator == value._creator &&
      _rotation == value._rotation;
}

bool Bullet::Update::operator!=(const Bullet::Update& value) const {
  return !operator==(value);
}

Bullet::Update Bullet::Update::FromInitialData(const ::automaton::player::BulletData& data) {
  Bullet::Update update;
  update._creator.emplace(data.creator());
  update._rotation.emplace(data.rotation());
  return update;
}

::automaton::player::BulletData Bullet::Update::ToInitialData() const {
  return ::automaton::player::BulletData(
      *_creator,
      *_rotation);
}

void Bullet::Update::ApplyTo(::automaton::player::BulletData& data) const {
  if (_creator) {
    data.set_creator(*_creator);
  }
  if (_rotation) {
    data.set_rotation(*_rotation);
  }
}

const ::worker::Option< ::worker::EntityId >& Bullet::Update::creator() const {
  return _creator;
}

::worker::Option< ::worker::EntityId >& Bullet::Update::creator() {
  return _creator;
}

Bullet::Update& Bullet::Update::set_creator(::worker::EntityId value) {
  _creator.emplace(value); return *this;
}

const ::worker::Option< ::automaton::Quaternion >& Bullet::Update::rotation() const {
  return _rotation;
}

::worker::Option< ::automaton::Quaternion >& Bullet::Update::rotation() {
  return _rotation;
}

Bullet::Update& Bullet::Update::set_rotation(const ::automaton::Quaternion& value) {
  _rotation.emplace(value); return *this;
}

// Serialization helpers.
//----------------------------------------------------------------

namespace detail {

void Write_BulletData(
    const ::automaton::player::BulletData& data, ::Pbio_Object* object) {
  ::Pbio_AddInt64(object, 1, data.creator());
  ::automaton::detail::Write_Quaternion(data.rotation(), ::Pbio_AddObject(object, 2));
}

::automaton::player::BulletData Read_BulletData(::Pbio_Object* object) {
  auto _creator = ::Pbio_GetInt64(object, 1);
  auto _rotation = ::automaton::detail::Read_Quaternion(::Pbio_GetObject(object, 2));
  return {
      std::move(_creator),
      std::move(_rotation)};
}

namespace {

void VtableBufferFree_Bullet(::worker::ComponentId, std::uint8_t* buffer) {
  delete[] buffer;
}

void VtableFree_Bullet(
    ::worker::ComponentId, std::uint8_t object_type,
    ::worker::detail::ClientObject* object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    delete static_cast< ::automaton::player::Bullet::Update* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    delete static_cast< ::automaton::player::BulletData* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request ||
             object_type == ::worker::detail::ClientComponentVtable::Response) {
    delete static_cast< GenericCommandObject_Bullet* >(object);
  }
}

::worker::detail::ClientObject* VtableCopy_Bullet(
    ::worker::ComponentId, std::uint8_t, ::worker::detail::ClientObject* object) {
  return object;
}

std::uint8_t VtableDeserialize_Bullet(
    ::worker::ComponentId, std::uint8_t object_type, const std::uint8_t* buffer,
    std::uint32_t length, ::worker::detail::ClientObject** object) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  ::Pbio_MergeFromBuffer(root, buffer, length);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    *object = new ::automaton::player::Bullet::Update;
    auto client_object = static_cast< ::automaton::player::Bullet::Update* >(*object);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::Pbio_GetObject(
          ::Pbio_GetObject(root, /* entity_state */ 2), 30003);
      if (::Pbio_GetInt64Count(state_object, 1)) {
        auto _creator = ::Pbio_GetInt64(state_object, 1);
        client_object->creator().emplace(std::move(_creator));
      }
      if (::Pbio_GetObjectCount(state_object, 2)) {
        auto _rotation = ::automaton::detail::Read_Quaternion(::Pbio_GetObject(state_object, 2));
        client_object->rotation().emplace(std::move(_rotation));
      }
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    *object = new ::automaton::player::BulletData{::automaton::player::detail::Read_BulletData(::Pbio_GetObject(root, 30003))};
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
  }
  return ::Pbio_HasError(pbio.get()) == 0;
}

void VtableSerialize_Bullet(
    ::worker::ComponentId, std::uint8_t object_type,
    const ::worker::detail::ClientObject* object, std::uint8_t** buffer,
    std::uint32_t* length) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  static_cast<void>(object);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    const auto& data = *static_cast< const ::automaton::player::Bullet::Update* >(object);
    {
      auto state_object = ::Pbio_AddObject(
          ::Pbio_AddObject(root, /* entity_state */ 2), 30003);
      if (data.creator()) {
        ::Pbio_AddInt64(state_object, 1, (*data.creator()));
      }
      if (data.rotation()) {
        ::automaton::detail::Write_Quaternion((*data.rotation()), ::Pbio_AddObject(state_object, 2));
      }
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::automaton::player::detail::Write_BulletData(
        *static_cast< const ::automaton::player::BulletData* >(object),
        ::Pbio_AddObject(root, 30003));
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    ::Pbio_AddObject(root, 30003);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    ::Pbio_AddObject(root, 30003);
  }
  *length = ::Pbio_GetWriteBufferLength(root);
  *buffer = new std::uint8_t[*length];
  ::Pbio_WriteToBuffer(root, *buffer);
}

}  // anonymous namespace

const ::worker::detail::ClientComponentVtable& Vtable_Bullet() {
  static const ::worker::detail::ClientComponentVtable vtable = {
      30003,
      &::automaton::player::detail::VtableBufferFree_Bullet,
      &::automaton::player::detail::VtableFree_Bullet,
      &::automaton::player::detail::VtableCopy_Bullet,
      &::automaton::player::detail::VtableDeserialize_Bullet,
      &::automaton::player::detail::VtableSerialize_Bullet,
  };
  return vtable;
}

}  // ::detail

}  // ::player
}  // ::automaton
