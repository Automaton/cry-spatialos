// Generated by SpatialOS codegen. DO NOT EDIT!
// source: improbable/standard_library.schema
#include <improbable/standard_library.h>
#include <improbable/protobuf_interop.h>

namespace improbable {

// Implementation of Coordinates.
//----------------------------------------------------------------

Coordinates::Coordinates(
    double x,
    double y,
    double z)
: _x{x}
, _y{y}
, _z{z} {}

Coordinates Coordinates::Create() {
  return {
      0,
      0,
      0};
}

bool Coordinates::operator==(const Coordinates& value) const {
  return
      _x == value._x &&
      _y == value._y &&
      _z == value._z;
}

bool Coordinates::operator!=(const Coordinates& value) const {
  return !operator==(value);
}

double Coordinates::x() const {
  return _x;
}

double& Coordinates::x() {
  return _x;
}

Coordinates& Coordinates::set_x(double value) {
  _x = value;
  return *this;
}

double Coordinates::y() const {
  return _y;
}

double& Coordinates::y() {
  return _y;
}

Coordinates& Coordinates::set_y(double value) {
  _y = value;
  return *this;
}

double Coordinates::z() const {
  return _z;
}

double& Coordinates::z() {
  return _z;
}

Coordinates& Coordinates::set_z(double value) {
  _z = value;
  return *this;
}

// Implementation of WorkerRequirementSet.
//----------------------------------------------------------------

WorkerRequirementSet::WorkerRequirementSet(const ::worker::List< ::improbable::WorkerAttributeSet >& attribute_set)
: _attribute_set{attribute_set} {}

WorkerRequirementSet WorkerRequirementSet::Create() {
  return {
      {}};
}

bool WorkerRequirementSet::operator==(const WorkerRequirementSet& value) const {
  return
      _attribute_set == value._attribute_set;
}

bool WorkerRequirementSet::operator!=(const WorkerRequirementSet& value) const {
  return !operator==(value);
}

const ::worker::List< ::improbable::WorkerAttributeSet >& WorkerRequirementSet::attribute_set() const {
  return _attribute_set;
}

::worker::List< ::improbable::WorkerAttributeSet >& WorkerRequirementSet::attribute_set() {
  return _attribute_set;
}

WorkerRequirementSet& WorkerRequirementSet::set_attribute_set(const ::worker::List< ::improbable::WorkerAttributeSet >& value) {
  _attribute_set = value;
  return *this;
}

// Implementation of EntityAclData.
//----------------------------------------------------------------

EntityAclData::EntityAclData(
    const ::improbable::WorkerRequirementSet& read_acl,
    const ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& component_write_acl)
: _read_acl{read_acl}
, _component_write_acl{component_write_acl} {}

EntityAclData EntityAclData::Create() {
  return {
      ::improbable::WorkerRequirementSet::Create(),
      {}};
}

bool EntityAclData::operator==(const EntityAclData& value) const {
  return
      _read_acl == value._read_acl &&
      _component_write_acl == value._component_write_acl;
}

bool EntityAclData::operator!=(const EntityAclData& value) const {
  return !operator==(value);
}

const ::improbable::WorkerRequirementSet& EntityAclData::read_acl() const {
  return _read_acl;
}

::improbable::WorkerRequirementSet& EntityAclData::read_acl() {
  return _read_acl;
}

EntityAclData& EntityAclData::set_read_acl(const ::improbable::WorkerRequirementSet& value) {
  _read_acl = value;
  return *this;
}

const ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& EntityAclData::component_write_acl() const {
  return _component_write_acl;
}

::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& EntityAclData::component_write_acl() {
  return _component_write_acl;
}

EntityAclData& EntityAclData::set_component_write_acl(const ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& value) {
  _component_write_acl = value;
  return *this;
}

// Implementation of MetadataData.
//----------------------------------------------------------------

MetadataData::MetadataData(const std::string& entity_type)
: _entity_type{entity_type} {}

MetadataData MetadataData::Create() {
  return {
      {}};
}

bool MetadataData::operator==(const MetadataData& value) const {
  return
      _entity_type == value._entity_type;
}

bool MetadataData::operator!=(const MetadataData& value) const {
  return !operator==(value);
}

const std::string& MetadataData::entity_type() const {
  return _entity_type;
}

std::string& MetadataData::entity_type() {
  return _entity_type;
}

MetadataData& MetadataData::set_entity_type(const std::string& value) {
  _entity_type = value;
  return *this;
}

// Implementation of PersistenceData.
//----------------------------------------------------------------

PersistenceData::PersistenceData() {}

PersistenceData PersistenceData::Create() {
  return {};
}

bool PersistenceData::operator==(const PersistenceData&) const {
  return true;
}

bool PersistenceData::operator!=(const PersistenceData& value) const {
  return !operator==(value);
}

// Implementation of PositionData.
//----------------------------------------------------------------

PositionData::PositionData(const ::improbable::Coordinates& coords)
: _coords{coords} {}

PositionData PositionData::Create() {
  return {
      ::improbable::Coordinates::Create()};
}

bool PositionData::operator==(const PositionData& value) const {
  return
      _coords == value._coords;
}

bool PositionData::operator!=(const PositionData& value) const {
  return !operator==(value);
}

const ::improbable::Coordinates& PositionData::coords() const {
  return _coords;
}

::improbable::Coordinates& PositionData::coords() {
  return _coords;
}

PositionData& PositionData::set_coords(const ::improbable::Coordinates& value) {
  _coords = value;
  return *this;
}

// Implementation of WorkerAttributeSet.
//----------------------------------------------------------------

WorkerAttributeSet::WorkerAttributeSet(const ::worker::List< std::string >& attribute)
: _attribute{attribute} {}

WorkerAttributeSet WorkerAttributeSet::Create() {
  return {
      {}};
}

bool WorkerAttributeSet::operator==(const WorkerAttributeSet& value) const {
  return
      _attribute == value._attribute;
}

bool WorkerAttributeSet::operator!=(const WorkerAttributeSet& value) const {
  return !operator==(value);
}

const ::worker::List< std::string >& WorkerAttributeSet::attribute() const {
  return _attribute;
}

::worker::List< std::string >& WorkerAttributeSet::attribute() {
  return _attribute;
}

WorkerAttributeSet& WorkerAttributeSet::set_attribute(const ::worker::List< std::string >& value) {
  _attribute = value;
  return *this;
}

// Implementation of EntityAcl.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId EntityAcl::ComponentId;

bool EntityAcl::Update::operator==(const EntityAcl::Update& value) const {
  return
      _read_acl == value._read_acl &&
      _component_write_acl == value._component_write_acl;
}

bool EntityAcl::Update::operator!=(const EntityAcl::Update& value) const {
  return !operator==(value);
}

EntityAcl::Update EntityAcl::Update::FromInitialData(const ::improbable::EntityAclData& data) {
  EntityAcl::Update update;
  update._read_acl.emplace(data.read_acl());
  update._component_write_acl.emplace(data.component_write_acl());
  return update;
}

::improbable::EntityAclData EntityAcl::Update::ToInitialData() const {
  return ::improbable::EntityAclData(
      *_read_acl,
      *_component_write_acl);
}

void EntityAcl::Update::ApplyTo(::improbable::EntityAclData& data) const {
  if (_read_acl) {
    data.set_read_acl(*_read_acl);
  }
  if (_component_write_acl) {
    data.set_component_write_acl(*_component_write_acl);
  }
}

const ::worker::Option< ::improbable::WorkerRequirementSet >& EntityAcl::Update::read_acl() const {
  return _read_acl;
}

::worker::Option< ::improbable::WorkerRequirementSet >& EntityAcl::Update::read_acl() {
  return _read_acl;
}

EntityAcl::Update& EntityAcl::Update::set_read_acl(const ::improbable::WorkerRequirementSet& value) {
  _read_acl.emplace(value); return *this;
}

const ::worker::Option< ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet > >& EntityAcl::Update::component_write_acl() const {
  return _component_write_acl;
}

::worker::Option< ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet > >& EntityAcl::Update::component_write_acl() {
  return _component_write_acl;
}

EntityAcl::Update& EntityAcl::Update::set_component_write_acl(const ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& value) {
  _component_write_acl.emplace(value); return *this;
}

// Implementation of Metadata.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Metadata::ComponentId;

bool Metadata::Update::operator==(const Metadata::Update& value) const {
  return
      _entity_type == value._entity_type;
}

bool Metadata::Update::operator!=(const Metadata::Update& value) const {
  return !operator==(value);
}

Metadata::Update Metadata::Update::FromInitialData(const ::improbable::MetadataData& data) {
  Metadata::Update update;
  update._entity_type.emplace(data.entity_type());
  return update;
}

::improbable::MetadataData Metadata::Update::ToInitialData() const {
  return ::improbable::MetadataData(*_entity_type);
}

void Metadata::Update::ApplyTo(::improbable::MetadataData& data) const {
  if (_entity_type) {
    data.set_entity_type(*_entity_type);
  }
}

const ::worker::Option< std::string >& Metadata::Update::entity_type() const {
  return _entity_type;
}

::worker::Option< std::string >& Metadata::Update::entity_type() {
  return _entity_type;
}

Metadata::Update& Metadata::Update::set_entity_type(const std::string& value) {
  _entity_type.emplace(value); return *this;
}

// Implementation of Position.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Position::ComponentId;

bool Position::Update::operator==(const Position::Update& value) const {
  return
      _coords == value._coords;
}

bool Position::Update::operator!=(const Position::Update& value) const {
  return !operator==(value);
}

Position::Update Position::Update::FromInitialData(const ::improbable::PositionData& data) {
  Position::Update update;
  update._coords.emplace(data.coords());
  return update;
}

::improbable::PositionData Position::Update::ToInitialData() const {
  return ::improbable::PositionData(*_coords);
}

void Position::Update::ApplyTo(::improbable::PositionData& data) const {
  if (_coords) {
    data.set_coords(*_coords);
  }
}

const ::worker::Option< ::improbable::Coordinates >& Position::Update::coords() const {
  return _coords;
}

::worker::Option< ::improbable::Coordinates >& Position::Update::coords() {
  return _coords;
}

Position::Update& Position::Update::set_coords(const ::improbable::Coordinates& value) {
  _coords.emplace(value); return *this;
}

// Implementation of Persistence.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Persistence::ComponentId;

bool Persistence::Update::operator==(const Persistence::Update&) const {
  return true;
}

bool Persistence::Update::operator!=(const Persistence::Update& value) const {
  return !operator==(value);
}

Persistence::Update Persistence::Update::FromInitialData(const ::improbable::PersistenceData&) {
  return Persistence::Update{};
}

::improbable::PersistenceData Persistence::Update::ToInitialData() const {
  return ::improbable::PersistenceData();
}

void Persistence::Update::ApplyTo(::improbable::PersistenceData&) const {
}

// Serialization helpers.
//----------------------------------------------------------------

namespace detail {

void Write_Coordinates(
    const ::improbable::Coordinates& data, ::Pbio_Object* object) {
  ::Pbio_AddDouble(object, 1, data.x());
  ::Pbio_AddDouble(object, 2, data.y());
  ::Pbio_AddDouble(object, 3, data.z());
}

::improbable::Coordinates Read_Coordinates(::Pbio_Object* object) {
  auto _x = ::Pbio_GetDouble(object, 1);
  auto _y = ::Pbio_GetDouble(object, 2);
  auto _z = ::Pbio_GetDouble(object, 3);
  return {
      std::move(_x),
      std::move(_y),
      std::move(_z)};
}

void Write_WorkerRequirementSet(
    const ::improbable::WorkerRequirementSet& data, ::Pbio_Object* object) {
  for (const auto& item : data.attribute_set()) {
    ::improbable::detail::Write_WorkerAttributeSet(item, ::Pbio_AddObject(object, 1));
  }
}

::improbable::WorkerRequirementSet Read_WorkerRequirementSet(::Pbio_Object* object) {
  ::worker::List< ::improbable::WorkerAttributeSet > _attribute_set;
  auto _attribute_set_count = ::Pbio_GetObjectCount(object, 1);
  for (std::uint32_t index = 0; index < _attribute_set_count; ++index) {
    _attribute_set.emplace_back(::improbable::detail::Read_WorkerAttributeSet(::Pbio_IndexObject(object, 1, index)));
  }
  return {
      std::move(_attribute_set)};
}

void Write_EntityAclData(
    const ::improbable::EntityAclData& data, ::Pbio_Object* object) {
  ::improbable::detail::Write_WorkerRequirementSet(data.read_acl(), ::Pbio_AddObject(object, 1));
  for (const auto& item : data.component_write_acl()) {
    auto pair = ::Pbio_AddObject(object, 2);
    ::Pbio_AddUint32(pair, 1, item.first);
    ::improbable::detail::Write_WorkerRequirementSet(item.second, ::Pbio_AddObject(pair, 2));
  }
}

::improbable::EntityAclData Read_EntityAclData(::Pbio_Object* object) {
  auto _read_acl = ::improbable::detail::Read_WorkerRequirementSet(::Pbio_GetObject(object, 1));
  ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet > _component_write_acl;
  auto _component_write_acl_count = ::Pbio_GetObjectCount(object, 2);
  for (std::uint32_t index = 0; index < _component_write_acl_count; ++index) {
    auto pair = ::Pbio_IndexObject(object, 2, index);
    _component_write_acl.emplace(::Pbio_GetUint32(pair, 1), ::improbable::detail::Read_WorkerRequirementSet(::Pbio_GetObject(pair, 2)));
  }
  return {
      std::move(_read_acl),
      std::move(_component_write_acl)};
}

void Write_MetadataData(
    const ::improbable::MetadataData& data, ::Pbio_Object* object) {
  ::Pbio_AddBytes(object, 1, reinterpret_cast<const std::uint8_t*>(data.entity_type().data()), static_cast<std::uint32_t>(data.entity_type().size()));
}

::improbable::MetadataData Read_MetadataData(::Pbio_Object* object) {
  auto _entity_type = [object] { auto _buffer = reinterpret_cast<const char*>(::Pbio_GetBytes(object, 1)); return std::string{_buffer, _buffer + ::Pbio_GetBytesLength(object, 1)}; }();
  return {
      std::move(_entity_type)};
}

void Write_PersistenceData(const ::improbable::PersistenceData&, ::Pbio_Object*) {}

::improbable::PersistenceData Read_PersistenceData(::Pbio_Object*) {
  return {};
}

void Write_PositionData(
    const ::improbable::PositionData& data, ::Pbio_Object* object) {
  ::improbable::detail::Write_Coordinates(data.coords(), ::Pbio_AddObject(object, 1));
}

::improbable::PositionData Read_PositionData(::Pbio_Object* object) {
  auto _coords = ::improbable::detail::Read_Coordinates(::Pbio_GetObject(object, 1));
  return {
      std::move(_coords)};
}

void Write_WorkerAttributeSet(
    const ::improbable::WorkerAttributeSet& data, ::Pbio_Object* object) {
  for (const auto& item : data.attribute()) {
    ::Pbio_AddBytes(object, 1, reinterpret_cast<const std::uint8_t*>(item.data()), static_cast<std::uint32_t>(item.size()));
  }
}

::improbable::WorkerAttributeSet Read_WorkerAttributeSet(::Pbio_Object* object) {
  ::worker::List< std::string > _attribute;
  auto _attribute_count = ::Pbio_GetBytesCount(object, 1);
  for (std::uint32_t index = 0; index < _attribute_count; ++index) {
    auto _buffer = reinterpret_cast<const char*>(::Pbio_IndexBytes(object, 1, index));
    _attribute.emplace_back(_buffer, _buffer + ::Pbio_IndexBytesLength(object, 1, index));
  }
  return {
      std::move(_attribute)};
}

namespace {

void VtableBufferFree_EntityAcl(::worker::ComponentId, std::uint8_t* buffer) {
  delete[] buffer;
}

void VtableFree_EntityAcl(
    ::worker::ComponentId, std::uint8_t object_type,
    ::worker::detail::ClientObject* object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    delete static_cast< ::improbable::EntityAcl::Update* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    delete static_cast< ::improbable::EntityAclData* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request ||
             object_type == ::worker::detail::ClientComponentVtable::Response) {
    delete static_cast< GenericCommandObject_EntityAcl* >(object);
  }
}

::worker::detail::ClientObject* VtableCopy_EntityAcl(
    ::worker::ComponentId, std::uint8_t, ::worker::detail::ClientObject* object) {
  return object;
}

std::uint8_t VtableDeserialize_EntityAcl(
    ::worker::ComponentId, std::uint8_t object_type, const std::uint8_t* buffer,
    std::uint32_t length, ::worker::detail::ClientObject** object) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  ::Pbio_MergeFromBuffer(root, buffer, length);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    *object = new ::improbable::EntityAcl::Update;
    auto client_object = static_cast< ::improbable::EntityAcl::Update* >(*object);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::Pbio_GetObject(
          ::Pbio_GetObject(root, /* entity_state */ 2), 50);
      if (::Pbio_GetObjectCount(state_object, 1)) {
        auto _read_acl = ::improbable::detail::Read_WorkerRequirementSet(::Pbio_GetObject(state_object, 1));
        client_object->read_acl().emplace(std::move(_read_acl));
      }
      if (::Pbio_GetObjectCount(state_object, 2) || fields_to_clear.count(2)) {
        ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet > _component_write_acl;
        auto _component_write_acl_count = ::Pbio_GetObjectCount(state_object, 2);
        for (std::uint32_t index = 0; index < _component_write_acl_count; ++index) {
          auto pair = ::Pbio_IndexObject(state_object, 2, index);
          _component_write_acl.emplace(::Pbio_GetUint32(pair, 1), ::improbable::detail::Read_WorkerRequirementSet(::Pbio_GetObject(pair, 2)));
        }
        client_object->component_write_acl().emplace(std::move(_component_write_acl));
      }
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    *object = new ::improbable::EntityAclData{::improbable::detail::Read_EntityAclData(::Pbio_GetObject(root, 50))};
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
  }
  return ::Pbio_HasError(pbio.get()) == 0;
}

void VtableSerialize_EntityAcl(
    ::worker::ComponentId, std::uint8_t object_type,
    const ::worker::detail::ClientObject* object, std::uint8_t** buffer,
    std::uint32_t* length) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  static_cast<void>(object);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    const auto& data = *static_cast< const ::improbable::EntityAcl::Update* >(object);
    {
      auto state_object = ::Pbio_AddObject(
          ::Pbio_AddObject(root, /* entity_state */ 2), 50);
      if (data.read_acl()) {
        ::improbable::detail::Write_WorkerRequirementSet((*data.read_acl()), ::Pbio_AddObject(state_object, 1));
      }
      if (data.component_write_acl()) {
        if (data.component_write_acl()->empty()) {
          ::Pbio_AddUint32(root, /* fields_to_clear */ 1, 2);
        }
        for (const auto& item : (*data.component_write_acl())) {
          auto pair = ::Pbio_AddObject(state_object, 2);
          ::Pbio_AddUint32(pair, 1, item.first);
          ::improbable::detail::Write_WorkerRequirementSet(item.second, ::Pbio_AddObject(pair, 2));
        }
      }
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::improbable::detail::Write_EntityAclData(
        *static_cast< const ::improbable::EntityAclData* >(object),
        ::Pbio_AddObject(root, 50));
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    ::Pbio_AddObject(root, 50);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    ::Pbio_AddObject(root, 50);
  }
  *length = ::Pbio_GetWriteBufferLength(root);
  *buffer = new std::uint8_t[*length];
  ::Pbio_WriteToBuffer(root, *buffer);
}

}  // anonymous namespace

const ::worker::detail::ClientComponentVtable& Vtable_EntityAcl() {
  static const ::worker::detail::ClientComponentVtable vtable = {
      50,
      &::improbable::detail::VtableBufferFree_EntityAcl,
      &::improbable::detail::VtableFree_EntityAcl,
      &::improbable::detail::VtableCopy_EntityAcl,
      &::improbable::detail::VtableDeserialize_EntityAcl,
      &::improbable::detail::VtableSerialize_EntityAcl,
  };
  return vtable;
}

namespace {

void VtableBufferFree_Metadata(::worker::ComponentId, std::uint8_t* buffer) {
  delete[] buffer;
}

void VtableFree_Metadata(
    ::worker::ComponentId, std::uint8_t object_type,
    ::worker::detail::ClientObject* object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    delete static_cast< ::improbable::Metadata::Update* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    delete static_cast< ::improbable::MetadataData* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request ||
             object_type == ::worker::detail::ClientComponentVtable::Response) {
    delete static_cast< GenericCommandObject_Metadata* >(object);
  }
}

::worker::detail::ClientObject* VtableCopy_Metadata(
    ::worker::ComponentId, std::uint8_t, ::worker::detail::ClientObject* object) {
  return object;
}

std::uint8_t VtableDeserialize_Metadata(
    ::worker::ComponentId, std::uint8_t object_type, const std::uint8_t* buffer,
    std::uint32_t length, ::worker::detail::ClientObject** object) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  ::Pbio_MergeFromBuffer(root, buffer, length);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    *object = new ::improbable::Metadata::Update;
    auto client_object = static_cast< ::improbable::Metadata::Update* >(*object);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::Pbio_GetObject(
          ::Pbio_GetObject(root, /* entity_state */ 2), 53);
      if (::Pbio_GetBytesCount(state_object, 1)) {
        auto _entity_type = [state_object] { auto _buffer = reinterpret_cast<const char*>(::Pbio_GetBytes(state_object, 1)); return std::string{_buffer, _buffer + ::Pbio_GetBytesLength(state_object, 1)}; }();
        client_object->entity_type().emplace(std::move(_entity_type));
      }
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    *object = new ::improbable::MetadataData{::improbable::detail::Read_MetadataData(::Pbio_GetObject(root, 53))};
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
  }
  return ::Pbio_HasError(pbio.get()) == 0;
}

void VtableSerialize_Metadata(
    ::worker::ComponentId, std::uint8_t object_type,
    const ::worker::detail::ClientObject* object, std::uint8_t** buffer,
    std::uint32_t* length) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  static_cast<void>(object);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    const auto& data = *static_cast< const ::improbable::Metadata::Update* >(object);
    {
      auto state_object = ::Pbio_AddObject(
          ::Pbio_AddObject(root, /* entity_state */ 2), 53);
      if (data.entity_type()) {
        ::Pbio_AddBytes(state_object, 1, reinterpret_cast<const std::uint8_t*>((*data.entity_type()).data()), static_cast<std::uint32_t>((*data.entity_type()).size()));
      }
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::improbable::detail::Write_MetadataData(
        *static_cast< const ::improbable::MetadataData* >(object),
        ::Pbio_AddObject(root, 53));
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    ::Pbio_AddObject(root, 53);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    ::Pbio_AddObject(root, 53);
  }
  *length = ::Pbio_GetWriteBufferLength(root);
  *buffer = new std::uint8_t[*length];
  ::Pbio_WriteToBuffer(root, *buffer);
}

}  // anonymous namespace

const ::worker::detail::ClientComponentVtable& Vtable_Metadata() {
  static const ::worker::detail::ClientComponentVtable vtable = {
      53,
      &::improbable::detail::VtableBufferFree_Metadata,
      &::improbable::detail::VtableFree_Metadata,
      &::improbable::detail::VtableCopy_Metadata,
      &::improbable::detail::VtableDeserialize_Metadata,
      &::improbable::detail::VtableSerialize_Metadata,
  };
  return vtable;
}

namespace {

void VtableBufferFree_Position(::worker::ComponentId, std::uint8_t* buffer) {
  delete[] buffer;
}

void VtableFree_Position(
    ::worker::ComponentId, std::uint8_t object_type,
    ::worker::detail::ClientObject* object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    delete static_cast< ::improbable::Position::Update* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    delete static_cast< ::improbable::PositionData* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request ||
             object_type == ::worker::detail::ClientComponentVtable::Response) {
    delete static_cast< GenericCommandObject_Position* >(object);
  }
}

::worker::detail::ClientObject* VtableCopy_Position(
    ::worker::ComponentId, std::uint8_t, ::worker::detail::ClientObject* object) {
  return object;
}

std::uint8_t VtableDeserialize_Position(
    ::worker::ComponentId, std::uint8_t object_type, const std::uint8_t* buffer,
    std::uint32_t length, ::worker::detail::ClientObject** object) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  ::Pbio_MergeFromBuffer(root, buffer, length);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    *object = new ::improbable::Position::Update;
    auto client_object = static_cast< ::improbable::Position::Update* >(*object);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::Pbio_GetObject(
          ::Pbio_GetObject(root, /* entity_state */ 2), 54);
      if (::Pbio_GetObjectCount(state_object, 1)) {
        auto _coords = ::improbable::detail::Read_Coordinates(::Pbio_GetObject(state_object, 1));
        client_object->coords().emplace(std::move(_coords));
      }
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    *object = new ::improbable::PositionData{::improbable::detail::Read_PositionData(::Pbio_GetObject(root, 54))};
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
  }
  return ::Pbio_HasError(pbio.get()) == 0;
}

void VtableSerialize_Position(
    ::worker::ComponentId, std::uint8_t object_type,
    const ::worker::detail::ClientObject* object, std::uint8_t** buffer,
    std::uint32_t* length) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  static_cast<void>(object);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    const auto& data = *static_cast< const ::improbable::Position::Update* >(object);
    {
      auto state_object = ::Pbio_AddObject(
          ::Pbio_AddObject(root, /* entity_state */ 2), 54);
      if (data.coords()) {
        ::improbable::detail::Write_Coordinates((*data.coords()), ::Pbio_AddObject(state_object, 1));
      }
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::improbable::detail::Write_PositionData(
        *static_cast< const ::improbable::PositionData* >(object),
        ::Pbio_AddObject(root, 54));
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    ::Pbio_AddObject(root, 54);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    ::Pbio_AddObject(root, 54);
  }
  *length = ::Pbio_GetWriteBufferLength(root);
  *buffer = new std::uint8_t[*length];
  ::Pbio_WriteToBuffer(root, *buffer);
}

}  // anonymous namespace

const ::worker::detail::ClientComponentVtable& Vtable_Position() {
  static const ::worker::detail::ClientComponentVtable vtable = {
      54,
      &::improbable::detail::VtableBufferFree_Position,
      &::improbable::detail::VtableFree_Position,
      &::improbable::detail::VtableCopy_Position,
      &::improbable::detail::VtableDeserialize_Position,
      &::improbable::detail::VtableSerialize_Position,
  };
  return vtable;
}

namespace {

void VtableBufferFree_Persistence(::worker::ComponentId, std::uint8_t* buffer) {
  delete[] buffer;
}

void VtableFree_Persistence(
    ::worker::ComponentId, std::uint8_t object_type,
    ::worker::detail::ClientObject* object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    delete static_cast< ::improbable::Persistence::Update* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    delete static_cast< ::improbable::PersistenceData* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request ||
             object_type == ::worker::detail::ClientComponentVtable::Response) {
    delete static_cast< GenericCommandObject_Persistence* >(object);
  }
}

::worker::detail::ClientObject* VtableCopy_Persistence(
    ::worker::ComponentId, std::uint8_t, ::worker::detail::ClientObject* object) {
  return object;
}

std::uint8_t VtableDeserialize_Persistence(
    ::worker::ComponentId, std::uint8_t object_type, const std::uint8_t* buffer,
    std::uint32_t length, ::worker::detail::ClientObject** object) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  ::Pbio_MergeFromBuffer(root, buffer, length);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    *object = new ::improbable::Persistence::Update;
    {
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    *object = new ::improbable::PersistenceData{::improbable::detail::Read_PersistenceData(::Pbio_GetObject(root, 55))};
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
  }
  return ::Pbio_HasError(pbio.get()) == 0;
}

void VtableSerialize_Persistence(
    ::worker::ComponentId, std::uint8_t object_type,
    const ::worker::detail::ClientObject* object, std::uint8_t** buffer,
    std::uint32_t* length) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  static_cast<void>(object);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    {
      ::Pbio_AddObject(
          ::Pbio_AddObject(root, /* entity_state */ 2), 55);
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::improbable::detail::Write_PersistenceData(
        *static_cast< const ::improbable::PersistenceData* >(object),
        ::Pbio_AddObject(root, 55));
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    ::Pbio_AddObject(root, 55);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    ::Pbio_AddObject(root, 55);
  }
  *length = ::Pbio_GetWriteBufferLength(root);
  *buffer = new std::uint8_t[*length];
  ::Pbio_WriteToBuffer(root, *buffer);
}

}  // anonymous namespace

const ::worker::detail::ClientComponentVtable& Vtable_Persistence() {
  static const ::worker::detail::ClientComponentVtable vtable = {
      55,
      &::improbable::detail::VtableBufferFree_Persistence,
      &::improbable::detail::VtableFree_Persistence,
      &::improbable::detail::VtableCopy_Persistence,
      &::improbable::detail::VtableDeserialize_Persistence,
      &::improbable::detail::VtableSerialize_Persistence,
  };
  return vtable;
}

}  // ::detail

}  // ::improbable
