// Generated by SpatialOS codegen. DO NOT EDIT!
// source: automaton/tree.schema
#include <automaton/tree.h>
#include <improbable/protobuf_interop.h>

namespace automaton {

// Implementation of TreeData.
//----------------------------------------------------------------

TreeData::TreeData(bool dead)
: _dead{dead} {}

TreeData TreeData::Create() {
  return {
      0};
}

bool TreeData::operator==(const TreeData& value) const {
  return
      _dead == value._dead;
}

bool TreeData::operator!=(const TreeData& value) const {
  return !operator==(value);
}

bool TreeData::dead() const {
  return _dead;
}

bool& TreeData::dead() {
  return _dead;
}

TreeData& TreeData::set_dead(bool value) {
  _dead = value;
  return *this;
}

// Implementation of Tree.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Tree::ComponentId;

bool Tree::Update::operator==(const Tree::Update& value) const {
  return
      _dead == value._dead;
}

bool Tree::Update::operator!=(const Tree::Update& value) const {
  return !operator==(value);
}

Tree::Update Tree::Update::FromInitialData(const ::automaton::TreeData& data) {
  Tree::Update update;
  update._dead.emplace(data.dead());
  return update;
}

::automaton::TreeData Tree::Update::ToInitialData() const {
  return ::automaton::TreeData(*_dead);
}

void Tree::Update::ApplyTo(::automaton::TreeData& data) const {
  if (_dead) {
    data.set_dead(*_dead);
  }
}

const ::worker::Option< bool >& Tree::Update::dead() const {
  return _dead;
}

::worker::Option< bool >& Tree::Update::dead() {
  return _dead;
}

Tree::Update& Tree::Update::set_dead(bool value) {
  _dead.emplace(value); return *this;
}

// Serialization helpers.
//----------------------------------------------------------------

namespace detail {

void Write_TreeData(
    const ::automaton::TreeData& data, ::Pbio_Object* object) {
  ::Pbio_AddBool(object, 1, static_cast<std::uint8_t>(data.dead()));
}

::automaton::TreeData Read_TreeData(::Pbio_Object* object) {
  auto _dead = ::Pbio_GetBool(object, 1) != 0;
  return {
      std::move(_dead)};
}

namespace {

void VtableBufferFree_Tree(::worker::ComponentId, std::uint8_t* buffer) {
  delete[] buffer;
}

void VtableFree_Tree(
    ::worker::ComponentId, std::uint8_t object_type,
    ::worker::detail::ClientObject* object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    delete static_cast< ::automaton::Tree::Update* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    delete static_cast< ::automaton::TreeData* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request ||
             object_type == ::worker::detail::ClientComponentVtable::Response) {
    delete static_cast< GenericCommandObject_Tree* >(object);
  }
}

::worker::detail::ClientObject* VtableCopy_Tree(
    ::worker::ComponentId, std::uint8_t, ::worker::detail::ClientObject* object) {
  return object;
}

std::uint8_t VtableDeserialize_Tree(
    ::worker::ComponentId, std::uint8_t object_type, const std::uint8_t* buffer,
    std::uint32_t length, ::worker::detail::ClientObject** object) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  ::Pbio_MergeFromBuffer(root, buffer, length);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    *object = new ::automaton::Tree::Update;
    auto client_object = static_cast< ::automaton::Tree::Update* >(*object);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::Pbio_GetObject(
          ::Pbio_GetObject(root, /* entity_state */ 2), 30020);
      if (::Pbio_GetBoolCount(state_object, 1)) {
        auto _dead = ::Pbio_GetBool(state_object, 1) != 0;
        client_object->dead().emplace(std::move(_dead));
      }
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    *object = new ::automaton::TreeData{::automaton::detail::Read_TreeData(::Pbio_GetObject(root, 30020))};
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
  }
  return ::Pbio_HasError(pbio.get()) == 0;
}

void VtableSerialize_Tree(
    ::worker::ComponentId, std::uint8_t object_type,
    const ::worker::detail::ClientObject* object, std::uint8_t** buffer,
    std::uint32_t* length) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  static_cast<void>(object);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    const auto& data = *static_cast< const ::automaton::Tree::Update* >(object);
    {
      auto state_object = ::Pbio_AddObject(
          ::Pbio_AddObject(root, /* entity_state */ 2), 30020);
      if (data.dead()) {
        ::Pbio_AddBool(state_object, 1, static_cast<std::uint8_t>((*data.dead())));
      }
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::automaton::detail::Write_TreeData(
        *static_cast< const ::automaton::TreeData* >(object),
        ::Pbio_AddObject(root, 30020));
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    ::Pbio_AddObject(root, 30020);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    ::Pbio_AddObject(root, 30020);
  }
  *length = ::Pbio_GetWriteBufferLength(root);
  *buffer = new std::uint8_t[*length];
  ::Pbio_WriteToBuffer(root, *buffer);
}

}  // anonymous namespace

const ::worker::detail::ClientComponentVtable& Vtable_Tree() {
  static const ::worker::detail::ClientComponentVtable vtable = {
      30020,
      &::automaton::detail::VtableBufferFree_Tree,
      &::automaton::detail::VtableFree_Tree,
      &::automaton::detail::VtableCopy_Tree,
      &::automaton::detail::VtableDeserialize_Tree,
      &::automaton::detail::VtableSerialize_Tree,
  };
  return vtable;
}

}  // ::detail

}  // ::automaton
