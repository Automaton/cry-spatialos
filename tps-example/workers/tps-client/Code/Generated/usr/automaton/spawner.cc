// Generated by SpatialOS codegen. DO NOT EDIT!
// source: automaton/spawner.schema
#include <automaton/spawner.h>
#include <improbable/protobuf_interop.h>

namespace automaton {

// Implementation of SpawnPlayerRequest.
//----------------------------------------------------------------

SpawnPlayerRequest::SpawnPlayerRequest(const ::improbable::Coordinates& position)
: _position{position} {}

SpawnPlayerRequest SpawnPlayerRequest::Create() {
  return {
      ::improbable::Coordinates::Create()};
}

bool SpawnPlayerRequest::operator==(const SpawnPlayerRequest& value) const {
  return
      _position == value._position;
}

bool SpawnPlayerRequest::operator!=(const SpawnPlayerRequest& value) const {
  return !operator==(value);
}

const ::improbable::Coordinates& SpawnPlayerRequest::position() const {
  return _position;
}

::improbable::Coordinates& SpawnPlayerRequest::position() {
  return _position;
}

SpawnPlayerRequest& SpawnPlayerRequest::set_position(const ::improbable::Coordinates& value) {
  _position = value;
  return *this;
}

// Implementation of SpawnPlayerResponse.
//----------------------------------------------------------------

SpawnPlayerResponse::SpawnPlayerResponse(
    bool success,
    const std::string& error_message,
    ::worker::EntityId created_entity_id)
: _success{success}
, _error_message{error_message}
, _created_entity_id{created_entity_id} {}

SpawnPlayerResponse SpawnPlayerResponse::Create() {
  return {
      0,
      {},
      0};
}

bool SpawnPlayerResponse::operator==(const SpawnPlayerResponse& value) const {
  return
      _success == value._success &&
      _error_message == value._error_message &&
      _created_entity_id == value._created_entity_id;
}

bool SpawnPlayerResponse::operator!=(const SpawnPlayerResponse& value) const {
  return !operator==(value);
}

bool SpawnPlayerResponse::success() const {
  return _success;
}

bool& SpawnPlayerResponse::success() {
  return _success;
}

SpawnPlayerResponse& SpawnPlayerResponse::set_success(bool value) {
  _success = value;
  return *this;
}

const std::string& SpawnPlayerResponse::error_message() const {
  return _error_message;
}

std::string& SpawnPlayerResponse::error_message() {
  return _error_message;
}

SpawnPlayerResponse& SpawnPlayerResponse::set_error_message(const std::string& value) {
  _error_message = value;
  return *this;
}

::worker::EntityId SpawnPlayerResponse::created_entity_id() const {
  return _created_entity_id;
}

::worker::EntityId& SpawnPlayerResponse::created_entity_id() {
  return _created_entity_id;
}

SpawnPlayerResponse& SpawnPlayerResponse::set_created_entity_id(::worker::EntityId value) {
  _created_entity_id = value;
  return *this;
}

// Implementation of SpawnerData.
//----------------------------------------------------------------

SpawnerData::SpawnerData() {}

SpawnerData SpawnerData::Create() {
  return {};
}

bool SpawnerData::operator==(const SpawnerData&) const {
  return true;
}

bool SpawnerData::operator!=(const SpawnerData& value) const {
  return !operator==(value);
}

// Implementation of Spawner.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Spawner::ComponentId;

constexpr const std::uint32_t Spawner::Commands::SpawnPlayer::CommandId;

bool Spawner::Update::operator==(const Spawner::Update&) const {
  return true;
}

bool Spawner::Update::operator!=(const Spawner::Update& value) const {
  return !operator==(value);
}

Spawner::Update Spawner::Update::FromInitialData(const ::automaton::SpawnerData&) {
  return Spawner::Update{};
}

::automaton::SpawnerData Spawner::Update::ToInitialData() const {
  return ::automaton::SpawnerData();
}

void Spawner::Update::ApplyTo(::automaton::SpawnerData&) const {
}

// Serialization helpers.
//----------------------------------------------------------------

namespace detail {

void Write_SpawnPlayerRequest(
    const ::automaton::SpawnPlayerRequest& data, ::Pbio_Object* object) {
  ::improbable::detail::Write_Coordinates(data.position(), ::Pbio_AddObject(object, 1));
}

::automaton::SpawnPlayerRequest Read_SpawnPlayerRequest(::Pbio_Object* object) {
  auto _position = ::improbable::detail::Read_Coordinates(::Pbio_GetObject(object, 1));
  return {
      std::move(_position)};
}

void Write_SpawnPlayerResponse(
    const ::automaton::SpawnPlayerResponse& data, ::Pbio_Object* object) {
  ::Pbio_AddBool(object, 1, static_cast<std::uint8_t>(data.success()));
  ::Pbio_AddBytes(object, 2, reinterpret_cast<const std::uint8_t*>(data.error_message().data()), static_cast<std::uint32_t>(data.error_message().size()));
  ::Pbio_AddInt64(object, 3, data.created_entity_id());
}

::automaton::SpawnPlayerResponse Read_SpawnPlayerResponse(::Pbio_Object* object) {
  auto _success = ::Pbio_GetBool(object, 1) != 0;
  auto _error_message = [object] { auto _buffer = reinterpret_cast<const char*>(::Pbio_GetBytes(object, 2)); return std::string{_buffer, _buffer + ::Pbio_GetBytesLength(object, 2)}; }();
  auto _created_entity_id = ::Pbio_GetInt64(object, 3);
  return {
      std::move(_success),
      std::move(_error_message),
      std::move(_created_entity_id)};
}

void Write_SpawnerData(const ::automaton::SpawnerData&, ::Pbio_Object*) {}

::automaton::SpawnerData Read_SpawnerData(::Pbio_Object*) {
  return {};
}

namespace {

void VtableBufferFree_Spawner(::worker::ComponentId, std::uint8_t* buffer) {
  delete[] buffer;
}

void VtableFree_Spawner(
    ::worker::ComponentId, std::uint8_t object_type,
    ::worker::detail::ClientObject* object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    delete static_cast< ::automaton::Spawner::Update* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    delete static_cast< ::automaton::SpawnerData* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request ||
             object_type == ::worker::detail::ClientComponentVtable::Response) {
    delete static_cast< GenericCommandObject_Spawner* >(object);
  }
}

::worker::detail::ClientObject* VtableCopy_Spawner(
    ::worker::ComponentId, std::uint8_t, ::worker::detail::ClientObject* object) {
  return object;
}

std::uint8_t VtableDeserialize_Spawner(
    ::worker::ComponentId, std::uint8_t object_type, const std::uint8_t* buffer,
    std::uint32_t length, ::worker::detail::ClientObject** object) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  ::Pbio_MergeFromBuffer(root, buffer, length);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    *object = new ::automaton::Spawner::Update;
    {
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    *object = new ::automaton::SpawnerData{::automaton::detail::Read_SpawnerData(::Pbio_GetObject(root, 30004))};
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    auto command_object = ::Pbio_GetObject(root, 30004);
    if (::Pbio_GetObjectCount(command_object, 1)) {
      *object = new ::automaton::detail::GenericCommandObject_Spawner{
          ::automaton::Spawner::Commands::SpawnPlayer::CommandId,
         ::automaton::detail::Read_SpawnPlayerRequest(::Pbio_GetObject(command_object, 1))};
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    auto command_object = ::Pbio_GetObject(root, 30004);
    if (::Pbio_GetObjectCount(command_object, 2)) {
      *object = new ::automaton::detail::GenericCommandObject_Spawner{
          ::automaton::Spawner::Commands::SpawnPlayer::CommandId,
          ::automaton::detail::Read_SpawnPlayerResponse(::Pbio_GetObject(command_object, 2))};
    }
  }
  return ::Pbio_HasError(pbio.get()) == 0;
}

void VtableSerialize_Spawner(
    ::worker::ComponentId, std::uint8_t object_type,
    const ::worker::detail::ClientObject* object, std::uint8_t** buffer,
    std::uint32_t* length) {
  std::unique_ptr< ::Pbio, void (*)(::Pbio*)> pbio{
      ::Pbio_Create(), ::Pbio_Destroy};
  auto root = ::Pbio_GetRootObject(pbio.get());
  static_cast<void>(object);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    {
      ::Pbio_AddObject(
          ::Pbio_AddObject(root, /* entity_state */ 2), 30004);
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::automaton::detail::Write_SpawnerData(
        *static_cast< const ::automaton::SpawnerData* >(object),
        ::Pbio_AddObject(root, 30004));
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    const auto& data = *static_cast< const GenericCommandObject_Spawner* >(object);
    auto command_object = ::Pbio_AddObject(root, 30004);
    if (data.CommandId == ::automaton::Spawner::Commands::SpawnPlayer::CommandId) {
      ::automaton::detail::Write_SpawnPlayerRequest(*data.CommandObject.data< ::automaton::SpawnPlayerRequest >(), ::Pbio_AddObject(command_object, 1));
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    const auto& data = *static_cast< const GenericCommandObject_Spawner* >(object);
    auto command_object = ::Pbio_AddObject(root, 30004);
    if (data.CommandId == ::automaton::Spawner::Commands::SpawnPlayer::CommandId) {
      ::automaton::detail::Write_SpawnPlayerResponse(*data.CommandObject.data< ::automaton::SpawnPlayerResponse >(), ::Pbio_AddObject(command_object, 2));
    }
  }
  *length = ::Pbio_GetWriteBufferLength(root);
  *buffer = new std::uint8_t[*length];
  ::Pbio_WriteToBuffer(root, *buffer);
}

}  // anonymous namespace

const ::worker::detail::ClientComponentVtable& Vtable_Spawner() {
  static const ::worker::detail::ClientComponentVtable vtable = {
      30004,
      &::automaton::detail::VtableBufferFree_Spawner,
      &::automaton::detail::VtableFree_Spawner,
      &::automaton::detail::VtableCopy_Spawner,
      &::automaton::detail::VtableDeserialize_Spawner,
      &::automaton::detail::VtableSerialize_Spawner,
  };
  return vtable;
}

}  // ::detail

}  // ::automaton
